<!doctype html>
<html lang="id">

<!-- Harusnya file saya lengkap seperti ini -->

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Video Player</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* ... (Gaya CSS tetap sama) ... */
        :root {
            --window-bg: #f0f0f0;
            --window-text: #000;
            --window-border: #a0a0a0;
            --control-hover-bg: #e6e6e6;
            --control-close-hover-bg: #e81123;
            --control-close-hover-text: white;

            /* Variabel Liquid Glass dari Control Panel */
            --c-glass: #f0f0f0;
            --c-light: #ffffff;
            --c-dark: #000000;
            --glass-reflex-dark: 1;
            --glass-reflex-light: 1;
            --saturation: 150%;

            /* --- NEW: Control Panel Theme Vars (Light/Default) --- */
            --control-bg: rgba(255, 255, 255, 0.9);
            /* Semi-transparent White */
            --control-text: #000000;
            --control-highlight: #ff6e40;
            /* Oranye/Coral agar sesuai referensi */

            /* Video Display Area Background (Always Dark) */
            --player-bg: #1c1c1c;
        }

        body.dark {
            --window-bg: #2b2b2b;
            --window-text: #f0f0f0;
            --window-border: #555555;
            --control-hover-bg: #3c3c3c;

            /* Variabel Liquid Glass - Mode Gelap */
            --c-glass: #2b2b2b;
            --glass-reflex-dark: 2;
            --glass-reflex-light: 0.3;

            /* --- NEW: Control Panel Theme Vars (Dark) --- */
            --control-bg: rgba(0, 0, 0, 0.9);
            /* Semi-transparent Black */
            --control-text: #f0f0f0;
        }

        /* --- Window Style --- */
        html,
        body {
            margin: 0;
            padding: 0;
            background-color: transparent;
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            color: var(--window-text);
            overflow: hidden;
            user-select: none;
        }

        /* Default "Safe Mode" style for the window */
        .app-window {
            display: flex;
            flex-direction: column;
            width: 100vw;
            height: 100vh;
            border: 1px solid var(--window-border);
            border-radius: 8px;
            background-color: var(--window-bg);
            transition:
                background-color 0.3s,
                border-radius 0.3s,
                box-shadow 0.3s;
            overflow: hidden;
        }

        /* "Fancy Mode" style with Liquid Glass effect for the main window */
        body.fancy-mode .app-window {
            background-color: color-mix(in srgb, var(--c-glass) 15%, transparent);
            backdrop-filter: blur(8px) url(#liquid-glass-filter) saturate(var(--saturation));
            -webkit-backdrop-filter: blur(8px) url(#liquid-glass-filter) saturate(var(--saturation));
            box-shadow:
                inset 0 0 0 1px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent),
                inset 1.8px 3px 0px -2px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 90%), transparent),
                inset -2px -2px 0px -2px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 80%), transparent),
                inset -3px -8px 1px -6px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 60%), transparent),
                inset -0.3px -1px 4px 0px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 12%), transparent),
                inset -1.5px 2.5px 0px -2px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 20%), transparent),
                inset 0px 3px 4px -2px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 20%), transparent),
                inset 2px -6.5px 1px -4px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent),
                0px 1px 5px 0px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent),
                0px 6px 16px 0px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 8%), transparent);
        }

        /* Header/Title Bar */
        .window-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            flex-shrink: 0;
            padding: 3px 3px 3px 6px;
        }

        .window-title-container {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .window-controls {
            display: flex;
        }

        /* Control Buttons (Minimize, Maximize) */
        .window-control-btn {
            width: 45px;
            height: 29px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            color: var(--window-text);
            font-size: 13px;
        }

        .window-control-btn:hover {
            background-color: var(--control-hover-bg);
        }

        /* Close Button */
        .close-window-btn {
            font-size: 22px;
            font-weight: 300;
            padding-bottom: 4px;
        }

        .close-window-btn:hover {
            background-color: var(--control-close-hover-bg);
            color: var(--control-close-hover-text);
        }

        /* Player specific styles (Menggunakan Variabel Baru) */
        .player-controls {
            color: var(--control-text);
            /* NEW */
            background-color: var(--control-bg);
            /* NEW */
            /* Padding disesuaikan agar pas */
            padding: 8px 16px 12px 16px;
            flex-shrink: 0;
            /* UPDATED: Tambahkan border-radius dan transisinya */
            border-radius: 0 0 8px 8px;
            transition: background-color 0.3s, color 0.3s, box-shadow 0.3s, border-radius 0.3s;
        }

        /* --- NEW: Fancy Mode for Controls --- */
        body.fancy-mode .player-controls {
            /* Terapkan Liquid Glass ke control bar */
            background-color: color-mix(in srgb, var(--c-glass) 15%, transparent);
            backdrop-filter: blur(8px) url(#liquid-glass-filter) saturate(var(--saturation));
            -webkit-backdrop-filter: blur(8px) url(#liquid-glass-filter) saturate(var(--saturation));
            box-shadow:
                0px -1px 3px 0px color-mix(in srgb, var(--c-dark) 5%, transparent),
                inset 0 1px 0 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 20%), transparent);
        }

        /* ------------------------------------- */

        .player-controls button {
            color: var(--control-text);
            /* NEW */
            transition: color 0.15s, background-color 0.15s, filter 0.15s;
            opacity: 0.9;
        }

        /* Tombol non-utama saat di-hover */
        .player-controls button:not(#play-pause-btn):hover {
            color: var(--control-highlight);
            /* NEW */
            opacity: 1;
        }

        /* Tombol Play/Pause Utama (Gaya Baru) */
        #play-pause-btn {
            width: 44px;
            /* w-11 */
            height: 44px;
            /* h-11 */
            border-radius: 9999px;
            background-color: var(--control-highlight);
            /* Warna solid agar menonjol */
            color: white;
            /* Ikon putih di atas warna highlight */
            opacity: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #play-pause-btn svg {
            width: 24px;
            /* w-6 */
            height: 24px;
            /* h-6 */
        }

        #play-pause-btn:hover {
            filter: brightness(1.1);
            /* Sedikit lebih terang saat di-hover */
            color: white;
            /* Pastikan tetap putih */
        }

        /* Tombol non-aktif (disabled) */
        .player-controls button:disabled {
            opacity: 0.4;
            color: var(--control-text);
            cursor: not-allowed;
        }

        #play-pause-btn:disabled {
            background-color: var(--control-highlight);
            opacity: 0.5;
            color: white;
        }


        /* Timeline Slider */
        .timeline-container {
            position: relative;
            width: 100%;
            height: 8px;
            /* Latar belakang timeline tetap netral agar highlight terlihat jelas */
            background: rgba(0, 0, 0, 0.3);
            border-radius: 999px;
            cursor: pointer;
            margin-top: 4px;
            /* Sedikit jarak dari atas */
        }

        .timeline-fill {
            position: absolute;
            height: 100%;
            background: var(--control-highlight);
            /* NEW */
            border-radius: 999px;
            width: 0%;
            z-index: 1;
        }

        .timeline-thumb {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            border-radius: 999px;
            background-color: var(--control-highlight);
            /* NEW */
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.4);
            cursor: grab;
            z-index: 2;
            transition: transform 0.1s;
        }

        .timeline-thumb:hover {
            transform: translate(-50%, -50%) scale(1.1);
        }

        .timeline-thumb:active {
            cursor: grabbing;
        }

        /* Drag and Drop Zone Style */
        .drop-zone {
            transition: background-color 0.3s;
        }

        .drop-zone.drag-over {
            background-color: rgba(255, 255, 255, 0.2) !important;
            border: 2px dashed var(--control-highlight) !important;
        }

        /* Video element style */
        #video-player {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
            height: 100%;
            object-fit: contain;
            /* Memastikan video tidak terpotong (sesuai permintaan) */
        }

        /* NEW: Video Display Area (Menggantikan #video-display dan #video-content-area) */
        #video-display-area {
            position: relative;
            flex-grow: 1;
            background-color: var(--player-bg);
            overflow: hidden;
        }

        /* Overlay sekarang berada di atas #video-display-area */
        #video-overlay {
            position: absolute;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: white;
            padding: 4px;
            transition: opacity 0.3s;
            pointer-events: auto;
        }

        /* Time Display (Baru: di samping timeline) */
        .time-display {
            color: var(--control-text);
            opacity: 0.8;
            transition: color 0.3s;
            font-size: 12px;
            font-family: monospace;
            white-space: nowrap;
        }


        #video-overlay.hidden-overlay {
            pointer-events: none;
            cursor: none;
        }

        /* CSS tambahan untuk memastikan tidak ada clipping di mode maximize (UPDATED) */
        .app-window.maximized {
            border: none;
        }

        .app-window.maximized .player-controls {
            border-radius: 0 !important;
            /* NEW: Ratakan sudut bawah saat maximize */
        }

        /* NEW: Info Video di Kiri Bawah */
        #video-info-display {
            min-width: 0;
            /* Biarkan flexbox yang mengatur */
        }

        #video-title-display {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 14px;
            max-width: 200px;
            /* Batasi lebar agar tidak mendominasi */
        }

        /* Styling native subtitle rendering (target video::cue pseudo-element) */
        /* Nonaktifkan CSS cue native karena kita akan menggunakan Octopus untuk ASS/SSA */
        #video-player::cue {
            background-color: rgba(0, 0, 0, 0.0);
            color: transparent;
            text-shadow: none;
            /* Pastikan subtitle native tidak terlihat, atau hapus elemen <track> */
        }


        /* NEW: Subtitle Menu Styling */
        #subtitle-menu {
            border: 1px solid var(--window-border);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        #subtitle-menu button {
            color: var(--control-text);
            background-color: var(--control-bg);
            opacity: 0.9;
        }

        body.dark #subtitle-menu button {
            color: var(--control-text);
            background-color: var(--control-bg);
        }

        /* NEW: Highlight selected subtitle track */
        #subtitle-menu button.selected-track {
            font-weight: bold;
            color: var(--control-highlight);
            /* Or another highlight color */
        }

        /* 2. Gaya untuk Canvas Subtitle Octopus (HARUS menutupi video) */
        #subtitle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            /* Di atas video, di bawah overlay pesan/drop-zone */
            pointer-events: none;
            /* Penting agar video dan drop zone tetap dapat diakses */
        }
    </style>
</head>

<body>
    <!-- Filter SVG for Liquid Glass effect -->
    <div style="position: absolute; width: 0; height: 0; z-index: -1">
        <svg>
            <filter id="liquid-glass-filter" primitiveUnits="objectBoundingBox">
                <feImage result="map" width="100%" height="100%" x="0" y="0" preserveAspectRatio="none"
                    href="img/svg-filter.jpg" />
                <feGaussianBlur in="SourceGraphic" stdDeviation="0.00" result="blur" />
                <feDisplacementMap id="disp" in="blur" in2="map" scale="0.4" xChannelSelector="R" yChannelSelector="G">
                </feDisplacementMap>
            </filter>
        </svg>
    </div>

    <div class="app-window">
        <!-- Window Header (Drag area) -->
        <div id="vp-window-header" class="window-header">
            <div class="window-title-container">
                <img src="img/films-and-tv_171100.png" alt="Video Icon" class="h-4 w-4" />
                <h2 class="text-sm font-normal">Video Player</h2>
            </div>
            <div class="window-controls">
                <button id="minimize-btn" class="window-control-btn" title="Minimize">
                    <svg width="10" height="2" viewBox="0 0 10 2" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M0 1H10V2H0V1Z" fill="currentColor" />
                    </svg>
                </button>
                <button id="maximize-btn" class="window-control-btn" title="Maximize">
                    <!-- Ikon default Maximize (kotak tunggal) -->
                    <svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M9 1V9H1V1H9ZM10 0H0V10H10V0Z" fill="currentColor" />
                    </svg>
                </button>
                <button id="close-btn" class="window-control-btn close-window-btn" title="Close">
                    &times;
                </button>
            </div>
        </div>

        <!-- Main Content Area: (UPDATED) Struktur diubah -->
        <div id="video-display-area" class="flex-grow relative drop-zone border-2 border-transparent"
            style="background-color: var(--player-bg); overflow: hidden;" title="Drop video file here">

            <!-- Elemen VIDEO -->
            <video id="video-player" poster="https://placehold.co/600x400/1c1c1c/ffffff?text=Drop+Video"
                crossorigin="anonymous">
                <!-- Track elements will be added here dynamically for VTT/SRT -->
            </video>

            <!-- 5. Tambahkan Canvas untuk Subtitle Octopus -->
            <canvas id="subtitle-canvas"></canvas>

            <!-- Overlay untuk tampilan Drag and Drop dan Pesan -->
            <div id="video-overlay" class="transition-opacity duration-300" style="opacity: 1;">
                <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="currentColor"
                    class="text-gray-300 mb-4">
                    <path
                        d="M18 10V5l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-9c-.7-.7-1.7-1-3-1zm1 1h-2v2h2v-2zm-2-12v4c0 1.1.9 2 2 2h4l-6-6zm-7 14.5l-4 3v-6l4 3z" />
                </svg>
                <p class="text-xl font-bold">Video Player</p>
                <p class="text-sm text-gray-300">
                    Drop a video file here (.mp4, .webm, .mkv)
                </p>
            </div>

            <!-- Elemen untuk menampilkan pesan error subtitle/status -->
            <div id="subtitle-status-message"
                class="absolute top-2 left-2 text-sm p-1 rounded-md text-yellow-400 bg-gray-800 bg-opacity-70 backdrop-blur-sm hidden z-20">
            </div>
        </div>

        <!-- (UPDATED) Kontrol wrapper sekarang menjadi anak langsung dari .app-window -->
        <div id="controls-wrapper" class="player-controls">

            <!-- NEW: Baris 1: Timeline dan Waktu -->
            <div class="flex items-center gap-3 w-full">
                <span id="time-display-current" class="time-display">00:00</span>
                <!-- Timeline Slider -->
                <div class="timeline-container flex-grow" id="timeline-container">
                    <div id="timeline-fill" class="timeline-fill"></div>
                    <div id="timeline-thumb" class="timeline-thumb"></div>
                </div>
                <span id="time-display-duration" class="time-display">00:00</span>
            </div>


            <!-- NEW: Baris 2: Tombol Kontrol Utama -->
            <div class="flex items-center justify-center w-full mt-1">

                <!-- Kiri: Info Video (Seperti di referensi) -->
                <div id="video-info-display" class="flex items-center gap-2 w-1/3 min-w-0 hidden">
                    <!-- Tambah min-w-0 -->
                    <svg class="w-8 h-8 opacity-70 flex-shrink-0" viewBox="0 0 24 24" fill="currentColor"
                        xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 10h-2v2h-2v-2H8v-2h2V8h2v2h2v2z" />
                    </svg>
                    <span id="video-title-display" class="text-sm truncate">Nama Video</span> <!-- Tambah truncate -->
                </div>

                <!-- Tengah: Kontrol Utama -->
                <div class="flex items-center justify-center gap-3 w-auto flex-shrink-0">
                    <!-- Ganti w-1/3 jadi w-auto -->
                    <button id="shuffle-btn" class="w-8 h-8 rounded-full flex items-center justify-center"
                        title="Shuffle" disabled>
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor"
                            xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z" />
                        </svg>
                    </button>

                    <button id="prev-btn" class="w-8 h-8 rounded-full flex items-center justify-center"
                        title="Skip Back 10s" disabled>
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor"
                            xmlns="http://www.w3.org/2000/svg">
                            <path d="M6 6h2v12H6zm3.5 6L18 18V6z" />
                        </svg>
                    </button>

                    <!-- Tombol Play/Pause (Gaya Baru) -->
                    <button id="play-pause-btn" title="Play/Pause" disabled>
                        <!-- Ikon Play: Segitiga -->
                        <svg id="play-icon" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M8 5v14l11-7z" />
                        </svg>
                        <!-- Ikon Pause: Dua baris (Disembunyikan) -->
                        <svg id="pause-icon" class="hidden" viewBox="0 0 24 24" fill="currentColor"
                            xmlns="http://www.w3.org/2000/svg">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                        </svg>
                    </button>

                    <button id="next-btn" class="w-8 h-8 rounded-full flex items-center justify-center"
                        title="Skip Forward 10s" disabled>
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor"
                            xmlns="http://www.w3.org/2000/svg">
                            <path d="M16 6h2v12h-2zm-4.5 6L6 18V6z" />
                        </svg>
                    </button>

                    <button id="repeat-btn" class="w-8 h-8 rounded-full flex items-center justify-center"
                        title="Repeat" disabled>
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor"
                            xmlns="http://www.w3.org/2000/svg">
                            <path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v3z" />
                        </svg>
                    </button>
                </div>

                <!-- Kanan: Kontrol Sekunder (Tambahkan 'relative' untuk menu dropdown) -->
                <div class="flex items-center justify-end gap-2 w-1/3 relative">
                    <button id="volume-btn" class="w-8 h-8 rounded-full flex items-center justify-center"
                        title="Volume">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor"
                            xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z" />
                        </svg>
                    </button>

                    <!-- NEW: Cast Button (Placeholder) -->
                    <button id="cast-btn" class="w-8 h-8 rounded-full flex items-center justify-center"
                        title="Cast (Not Implemented)" disabled>
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor"
                            xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M21 3H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm0-4v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11z" />
                        </svg>
                    </button>

                    <!-- NEW: Tombol Subtitle (Tambahkan class transition dan highlight) -->
                    <button id="subtitle-btn"
                        class="w-8 h-8 rounded-full flex items-center justify-center transition-colors duration-200"
                        title="Subtitles" disabled>
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor"
                            xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M18 5v14H6V5h12m2-2H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 9h6v2H9V9zm0 4h6v2H9v-2z" />
                        </svg>
                    </button>

                    <!-- NEW: Menu Subtitle Dropdown -->
                    <div id="subtitle-menu"
                        class="absolute bottom-full right-0 mb-2 w-48 rounded-lg shadow-xl py-1 z-30 hidden"
                        style="background-color: var(--control-bg);">
                        <div class="px-3 py-2 text-xs font-semibold uppercase text-gray-500 dark:text-gray-400">Subtitle
                            Tracks</div>
                        <!-- Konten akan diisi oleh JS -->
                        <div id="subtitle-track-list">
                            <!-- Tracks akan dimasukkan di sini -->
                        </div>
                    </div>

                    <button id="fullscreen-btn" class="w-8 h-8 rounded-full flex items-center justify-center"
                        title="Fullscreen" disabled>
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor"
                            xmlns="http://www.w3.org/2000/svg">
                            <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" />
                        </svg>
                    </button>

                    <!-- NEW: More Button (Placeholder) -->
                    <button id="more-btn" class="w-8 h-8 rounded-full flex items-center justify-center"
                        title="More (Not Implemented)" disabled>
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor"
                            xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- HAPUS Pustaka MatroskaSubtitles: Kita akan menggunakan FFmpeg/FFprobe Worker -->
    <!-- <script src="js/matroska-subtitles.min.js"></script> -->

    <!-- REINSTATE: Static load of Subtitles Octopus. This must execute before the main script. -->
    <script src="js/subtitles-octopus.js"></script> 

    <script>
        // --- PROMISE GLOBAL untuk memastikan Octopus siap ---
        // Variabel ini tidak diperlukan lagi karena kita menggunakan pemuatan statis.
        // let octopusReadyPromise;

        // --- FFmpeg/FFprobe Worker Paths ---
        // Sudah benar didalam subdir js/
        const FFPROBE_WORKER_PATH = 'js/ffprobe-worker-mkve.js'; 
        const FFMPEG_WORKER_PATH = 'js/ffmpeg-worker-mkve.js'; 
        
        const OCTOPUS_WORKER_PATH = 'js/subtitles-octopus-worker.js'; 


        // Helper untuk Mutex (untuk memastikan hanya satu worker yang berjalan)
        const Mutex = class {
            constructor() { this.locked = false; this.queue = []; }
            acquire() {
                return new Promise(resolve => {
                    if (!this.locked) {
                        this.locked = true;
                        resolve(() => { this.locked = false; this.dequeue(); });
                    } else {
                        this.queue.push(resolve);
                    }
                });
            }
            dequeue() {
                if (this.queue.length > 0) {
                    const resolve = this.queue.shift();
                    this.locked = true;
                    resolve(() => { this.locked = false; this.dequeue(); });
                }
            }
        };
        const mutex = new Mutex();

        // Elemen DOM
        const header = document.getElementById("vp-window-header");
        const closeBtn = document.getElementById("close-btn");
        const minimizeBtn = document.getElementById("minimize-btn");
        const maximizeBtn = document.getElementById("maximize-btn");
        const appWindow = document.querySelector(".app-window");
        const videoDisplayArea = document.getElementById("video-display-area");
        const videoPlayer = document.getElementById("video-player");
        const subtitleCanvas = document.getElementById("subtitle-canvas"); // NEW: Canvas for Octopus
        const videoOverlay = document.getElementById("video-overlay");
        const controlsWrapper = document.getElementById("controls-wrapper");
        const shuffleBtn = document.getElementById("shuffle-btn");
        const prevBtn = document.getElementById("prev-btn");
        const playPauseBtn = document.getElementById("play-pause-btn");
        const nextBtn = document.getElementById("next-btn");
        const repeatBtn = document.getElementById("repeat-btn");
        const playIcon = document.getElementById("play-icon");
        const pauseIcon = document.getElementById("pause-icon");
        const timeDisplayCurrent = document.getElementById("time-display-current");
        const timeDisplayDuration = document.getElementById("time-display-duration");
        const timelineContainer = document.getElementById("timeline-container");
        const timelineFill = document.getElementById("timeline-fill");
        const timelineThumb = document.getElementById("timeline-thumb");
        const videoInfoDisplay = document.getElementById("video-info-display");
        const videoTitleDisplay = document.getElementById("video-title-display");
        const volumeBtn = document.getElementById("volume-btn");
        const castBtn = document.getElementById("cast-btn");
        const fullscreenBtn = document.getElementById("fullscreen-btn");
        const moreBtn = document.getElementById("more-btn");
        const subtitleBtn = document.getElementById("subtitle-btn");
        const subtitleMenu = document.getElementById("subtitle-menu");
        const subtitleTrackList = document.getElementById("subtitle-track-list");
        const subtitleStatusMsg = document.getElementById("subtitle-status-message");

        // Variabel state
        let isDragging = false;
        let isMaximized = false;
        let isTimelineDragging = false;
        let currentFileURL = null;
        // Struktur subtitleTracks diubah agar lebih sederhana untuk FFmpeg
        let subtitleTracks = []; // Menyimpan data subtitle yang diekstrak { index, label, language, codec_name, content: ass/vtt String }
        let currentTrackURL = null; // Menyimpan URL blob VTT yang aktif
        let videoFileReference = null;
        let currentSubtitleTrackElement = null; // Menyimpan referensi ke elemen <track> yang sedang aktif
        let decoder = new TextDecoder('utf-8'); // Decoder untuk output teks worker
        let octopusRenderer = null; // NEW: Instance SubtitleOctopus
        
        // NEW: Interval untuk sinkronisasi waktu subtitle
        let subtitleSyncInterval = null;


        // --- FFMPEG/FFPROBE WORKER UTILITY FUNCTIONS ---
        // (runFFprobe dan runFFmpeg tetap sama)

        function runFFprobe(file) {
            console.log(`[FFprobe] Memproses file: ${file.name}`);
            return new Promise(async (resolve, reject) => {
                const release = await mutex.acquire(); // Gunakan Mutex
                try {
                    const worker = new Worker(FFPROBE_WORKER_PATH);
                    let stdout = '';
                    let stderr = '';

                    worker.addEventListener('error', error => {
                        console.error(`[FFprobe Worker Error] File: ${file.name}`, error.message);
                        resolve({ error: error.message, stdout, stderr });
                        worker.terminate();
                    });

                    worker.addEventListener('message', e => {
                        const msg = e.data;
                        switch (msg.type) {
                            case 'ready':
                                worker.postMessage({
                                    type: 'run',
                                    arguments: [
                                        '-i', '/data/' + file.name,
                                        '-print_format', 'json',
                                        '-show_streams',
                                        '-show_format',
                                    ],
                                    mounts: [{
                                        type: 'WORKERFS',
                                        opts: { files: [file] },
                                        mountpoint: '/data'
                                    }]
                                });
                                break;
                            case 'stdout':
                                stdout += msg.data;
                                break;
                            case 'stderr':
                                stderr += msg.data;
                                break;
                            case 'done':
                                let parsed, error;
                                try {
                                    parsed = JSON.parse(stdout);
                                } catch (err) {
                                    error = err;
                                    console.error(`[FFprobe Parse Error] File: ${file.name}`, err, 'Stderr:', stderr);
                                } finally {
                                    resolve({ parsed, error, stdout, stderr });
                                    worker.terminate();
                                }
                                break;
                        }
                    });
                } catch (e) {
                    console.error(`[FFprobe Initialization Error] Gagal membuat worker untuk: ${file.name}`, e);
                    reject(e);
                } finally {
                    release(); // Lepaskan Mutex
                }
            });
        }

        function runFFmpeg(file, argv) {
            console.log(`[FFmpeg] Menjalankan perintah: ${argv.join(' ')}`);
            return new Promise(async (resolve, reject) => {
                const release = await mutex.acquire(); // Gunakan Mutex
                try {
                    const worker = new Worker(FFMPEG_WORKER_PATH);
                    let stderr = '';

                    function messageHandler(e) {
                        const msg = e.data;
                        switch (msg.type) {
                            case 'ready':
                                worker.postMessage({
                                    type: 'run',
                                    arguments: argv,
                                    mounts: [{
                                        type: 'WORKERFS',
                                        opts: { files: [file] },
                                        mountpoint: '/data'
                                    }]
                                });
                                break;
                            case 'stderr':
                                stderr += msg.data + '\n';
                                break;
                            case 'done':
                                const files = msg.data.MEMFS;
                                console.log(`[FFmpeg] Perintah selesai. Jumlah file yang diekstrak: ${files.length}.`);
                                resolve({ files, stderr });
                                worker.removeEventListener('message', messageHandler);
                                worker.terminate();
                                break;
                        }
                    }
                    worker.addEventListener('message', messageHandler);
                    worker.addEventListener('error', (e) => {
                        console.error(`[FFmpeg Worker Error] Fatal error in worker for ${file.name}:`, e);
                        reject(e);
                    });
                } catch (e) {
                    console.error(`[FFmpeg Initialization Error] Gagal membuat worker untuk: ${file.name}`, e);
                    reject(e);
                } finally {
                    release(); // Lepaskan Mutex
                }
            });
        }

        /**
         * Mengonversi konten SRT (SubRip Text) ke format WebVTT.
         */
        function srtToVtt(srtText) {
            let vtt = "WEBVTT\n\n";

            // Fungsi untuk membersihkan dan memformat waktu dari SRT (HH:MM:SS,ms) ke VTT (HH:MM:SS.ms)
            const convertTime = (timeStr) => timeStr.replace(',', '.'); // Mengganti koma desimal (SRT) dengan titik (VTT)

            // Memisahkan blok subtitle
            const srtBlocks = srtText.split(/\r?\n\r?\n/);

            for (const block of srtBlocks) {
                const lines = block.split(/\r?\n/).filter(line => line.trim() !== '');

                // SRT cue biasanya dimulai dengan nomor urut, diikuti baris waktu, lalu teks.
                if (lines.length >= 2) {
                    let timeLine = null;
                    let textLines = [];

                    // Cari baris waktu, biasanya yang kedua setelah nomor cue.
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i].includes('-->')) {
                            timeLine = lines[i];
                            textLines = lines.slice(i + 1);
                            break;
                        }
                        // Jika baris pertama bukan waktu, abaikan nomor urut
                    }

                    if (!timeLine) continue;

                    const [startTimeStr, endTimeStr] = timeLine.split('-->').map(s => s.trim());
                    const vttTimeLine = `${convertTime(startTimeStr)} --> ${convertTime(endTimeStr)}`;

                    let text = textLines.join('\n').trim();

                    // Bersihkan tag font/style dasar (hanya yang paling umum)
                    text = text.replace(/<[^>]*>/g, '').trim();
                    text = text.replace(/\n\s*\n/g, '\n'); // Hapus baris kosong ekstra

                    if (text) {
                        vtt += `${vttTimeLine}\n`;
                        vtt += `${text}\n\n`;
                    }
                }
            }
            return vtt;
        }


        /**
         * Menggunakan FFprobe untuk mendapatkan daftar stream subtitle, dan FFmpeg
         * untuk mengekstraknya, lalu mengonversi ke VTT (jika SRT) atau menyimpannya
         * mentah (jika ASS/SSA).
         */
        async function extractAndProcessMkvSubtitles(file) {
            if (!file || !file.name.toLowerCase().endsWith('.mkv')) {
                return [];
            }

            showSubtitleStatus(`Menganalisis file MKV dengan FFprobe: ${file.name}...`, 'info');

            // 1. Jalankan FFprobe
            const probeResult = await runFFprobe(file);
            const streams = probeResult.parsed?.streams;

            if (probeResult.error || !streams) {
                const errorMsg = `FFprobe gagal atau tidak menemukan stream. Cek console log.`;
                showSubtitleStatus(errorMsg, 'error');
                return [];
            }

            // 2. Filter stream subtitle berbasis teks
            // Termasuk ASS/SSA yang akan kita render dengan Octopus
            const subtitleStreams = streams.filter(s =>
                s.codec_type === 'subtitle' && (s.codec_name === 'subrip' || s.codec_name === 'ass' || s.codec_name === 'ssa' || s.codec_name === 'mov_text')
            );

            if (subtitleStreams.length === 0) {
                showSubtitleStatus("Tidak ada track subtitle berbasis teks yang ditemukan.", 'warning');
                return [];
            }

            showSubtitleStatus(`Ditemukan ${subtitleStreams.length} track subtitle. Mengekstrak...`, 'info');

            const tracks = [];
            let conversionErrors = [];

            // 3. Ekstrak dan Konversi setiap stream
            for (const stream of subtitleStreams) {
                const streamIndex = stream.index;
                const codecName = stream.codec_name.toLowerCase();
                const language = stream.tags?.language || 'und';
                const title = stream.tags?.title || '';
                const isAssSsa = codecName === 'ass' || codecName === 'ssa';
                const label = `${title ? title + ' ' : ''} (${codecName.toUpperCase()}, ${language}) #${streamIndex}`;

                // Tentukan ekstensi output berdasarkan codec agar FFmpeg bisa menyalin tanpa encoder
                const outputExt = (codecName === 'subrip' || codecName === 'mov_text') ? 'srt' :
                    isAssSsa ? 'ass' : 'txt'; // ASS/SSA diekstrak sebagai ASS

                const tempFileName = `stream_${streamIndex}.${outputExt}`;

                try {
                    // Perintah FFmpeg: COPY stream apa adanya (untuk menghindari masalah 'Unknown encoder')
                    const ffmpegResult = await runFFmpeg(file, [
                        '-i', '/data/' + file.name,
                        '-map', `0:${streamIndex}`, // Gunakan indeks stream yang benar
                        '-c:s', 'copy', // Salin stream mentah
                        '-f', outputExt, // Format output harus sesuai ekstensi (srt/ass/txt)
                        '-y',
                        tempFileName
                    ]);

                    const extractedFile = ffmpegResult.files.find(f => f.name === tempFileName);
                    let finalContent = "";

                    if (extractedFile && extractedFile.data.byteLength > 0) {
                        const rawText = decoder.decode(extractedFile.data);

                        // 4. Konversi ke VTT (jika SRT) atau simpan mentah (jika ASS/SSA)
                        if (codecName === 'subrip' || codecName === 'mov_text') {
                            // Coba konversi dari SRT/SubRip (yang dikeluarkan FFmpeg) ke VTT
                            finalContent = srtToVtt(rawText);
                            showSubtitleStatus("Track SRT/MOV_TEXT dikonversi ke VTT.", 'info');
                        } else if (isAssSsa) {
                            finalContent = rawText; // Simpan ASS/SSA mentah untuk Octopus
                            showSubtitleStatus("Track ASS/SSA diekstrak mentah.", 'info');
                        }

                        if (finalContent && finalContent.trim().length > 10) {
                            tracks.push({
                                index: streamIndex,
                                label: label,
                                language: language,
                                codec_name: codecName,
                                content: finalContent, // Ini bisa berupa VTT atau ASS mentah
                            });
                            console.log(`[FFmpeg] Track ${streamIndex} berhasil disalin dan diproses.`);
                        } else {
                            conversionErrors.push(`Track ${streamIndex} (${codecName}) disalin tetapi konten kosong.`);
                            console.warn(`[FFmpeg] Gagal memproses, output mentah terlalu pendek/kosong untuk stream ${streamIndex}.`);
                            console.error(`[FFmpeg Raw Stderr]: ${ffmpegResult.stderr.slice(-500)}`);
                        }
                    } else {
                        // Jika files.length == 0 atau byteLength == 0
                        conversionErrors.push(`Gagal menyalin track ${streamIndex} (${codecName}). Stderr: ${ffmpegResult.stderr.slice(-500)}`);
                        console.error(`[FFmpeg] Gagal menyalin/output file kosong untuk stream ${streamIndex}. Stderr: ${ffmpegResult.stderr.slice(-500)}`);
                    }

                } catch (e) {
                    const errMsg = `Error fatal saat memproses track ${streamIndex}: ${e.message}`;
                    conversionErrors.push(errMsg);
                    console.error(errMsg, e);
                }
            }

            if (conversionErrors.length > 0) {
                showSubtitleStatus(`Selesai, tetapi ${conversionErrors.length} track gagal diproses.`, 'warning');
            } else if (tracks.length > 0) {
                showSubtitleStatus(`Berhasil memproses ${tracks.length} track subtitle!`, 'success');
            } else {
                showSubtitleStatus("Tidak ada track subtitle yang berhasil diekstrak.", 'warning');
            }

            return tracks;
        }

        // --- Fungsi Helper ---
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return '00:00';
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function toggleControlsActive(active) {
            const elements = [shuffleBtn, prevBtn, playPauseBtn, nextBtn, repeatBtn, fullscreenBtn, volumeBtn, subtitleBtn];
            elements.forEach(el => {
                // Shuffle, Repeat, Cast, More tetap dinonaktifkan sementara
                if (['shuffle-btn', 'repeat-btn', 'cast-btn', 'more-btn'].includes(el.id)) {
                    el.disabled = true; // Selalu nonaktif sementara
                } else if (el.id === 'subtitle-btn') {
                    // Tombol subtitle diaktifkan hanya jika ada track DAN video aktif
                    el.disabled = !active || subtitleTracks.length === 0;
                } else {
                    el.disabled = !active;
                }
            });

            // Tampilkan/sembunyikan info video
            if (active && videoTitleDisplay.textContent !== "Nama Video") {
                videoInfoDisplay.classList.remove('hidden');
            } else {
                videoInfoDisplay.classList.add('hidden');
            }

            // Sembunyikan/tampilkan overlay utama
            if (active) {
                if (videoPlayer.paused && !videoPlayer.ended) { // Tampilkan hanya jika paused, bukan ended
                    videoOverlay.style.opacity = '1';
                    videoOverlay.classList.remove('hidden-overlay');
                    videoOverlay.querySelector('.text-xl').textContent = 'Video Paused';
                    videoOverlay.querySelector('p').textContent = 'Press Play or Spacebar';
                    videoOverlay.querySelector('svg').classList.add('hidden');
                } else {
                    videoOverlay.style.opacity = '0';
                    videoOverlay.classList.add('hidden-overlay');
                }
            } else {
                // Mode tidak aktif/Belum ada media
                videoOverlay.style.opacity = '1';
                videoOverlay.classList.remove('hidden-overlay');
                videoOverlay.querySelector('p').textContent = 'Drop a video file here (.mp4, .webm, .mkv)';
                videoOverlay.querySelector('.text-xl').textContent = 'Video Player';
                videoOverlay.querySelector('svg').classList.remove('hidden');
                timeDisplayCurrent.textContent = '00:00';
                timeDisplayDuration.textContent = '00:00';
                videoTitleDisplay.textContent = "Nama Video"; // Reset judul
                subtitleBtn.disabled = true; // Pastikan tombol subtitle nonaktif saat tidak ada video
            }
        }

        // --- FUNGSI SUBTITLE UI & LOGIC (UPDATED) ---

        /**
         * 4. Inisialisasi atau Hapus Renderer Octopus
         */
        function initializeOctopus(assContent) {
            console.log("[Octopus Init] Memulai inisialisasi SubtitlesOctopus.");
            
            // Hapus instance lama
            if (octopusRenderer) {
                octopusRenderer.dispose();
                octopusRenderer = null;
                console.log("[Octopus Init] Renderer lama dihapus.");
            }

            // Hapus interval sync lama
            if (subtitleSyncInterval) {
                clearInterval(subtitleSyncInterval);
                subtitleSyncInterval = null;
            }

            // === FIX 3: Pemeriksaan Eksplisit untuk Elemen DOM (Sesuai saran forum) ===
            const videoElement = document.getElementById('video-player');
            const canvasElement = document.getElementById('subtitle-canvas');
            
            console.log(`[Octopus Init] Status DOM: Video tersedia: ${!!videoElement}, Canvas tersedia: ${!!canvasElement}`);

            if (!videoElement || !canvasElement) {
                const errorMsg = `Elemen DOM tidak ditemukan. Video: ${!!videoElement}, Canvas: ${!!canvasElement}. Tidak dapat menginisialisasi SubtitlesOctopus.`;
                console.error(`[Octopus Init] ERROR: ${errorMsg}`);
                showSubtitleStatus(`Error: ${errorMsg}`, 'error');
                return; // Hentikan eksekusi jika elemen tidak ditemukan
            }
            // ====================================================================
            
            // Logik konten ASS
            if (!assContent) {
                console.log("[Octopus Init] Konten ASS kosong. Octopus dimatikan.");
                canvasElement.style.display = 'none'; // Gunakan canvasElement
                return;
            }
            console.log("[Octopus Init] Konten ASS/SSA ditemukan. Melanjutkan...");
            canvasElement.style.display = 'block'; // Gunakan canvasElement

            try {
                // Pemeriksaan eksplisit untuk SubtitleOctopus
                if (typeof SubtitlesOctopus === 'undefined') {
                    throw new Error("Pustaka SubtitleOctopus tidak terdefinisi. Pastikan 'js/subtitles-octopus.js' berhasil dimuat.");
                }
                console.log("[Octopus Init] Pustaka SubtitlesOctopus terdefinisi. Membuat instance...");

                // Perhatian: Kami MENGHINDARI mengirim elemen 'video' di opsi.
                // Ini mencegah SubtitlesOctopus secara internal memanggil resize()
                // dan menginisialisasi event listener-nya sendiri, yang memicu
                // error getBoundingClientRect. Kami akan mengelola resize dan waktu sendiri.
                octopusRenderer = new SubtitlesOctopus({
                    canvas: canvasElement, // Gunakan canvasElement yang telah diperiksa
                    subContent: assContent,
                    fonts: [],
                    workerUrl: OCTOPUS_WORKER_PATH,
                    // FIX 1: Set fallbackFont ke null untuk mencegah error worker
                    // Error terjadi karena worker mencoba memuat 'default.woff2' yang tidak ada di path /js/
                    fallbackFont: null
                });
                console.log("[Octopus Init] Renderer ASS/SSA berhasil diinisialisasi.");

                // Panggil resize secara manual setelah inisialisasi berhasil.
                // Ini akan memastikan canvas di resize sebelum frame pertama dirender.
                resizeSubtitleCanvas(); 

                // === FIX 5: Mulai interval sinkronisasi waktu ===
                // Kami harus secara manual memberi tahu Octopus waktu saat ini karena kami tidak memberikan elemen <video> padanya.
                subtitleSyncInterval = setInterval(() => {
                    // FIX 2: Periksa apakah renderer masih ada dan memiliki worker sebelum memanggil postMessage
                    if (videoPlayer && !videoPlayer.paused && octopusRenderer && octopusRenderer.worker) {
                        octopusRenderer.setCurrentTime(videoPlayer.currentTime);
                    }
                }, 100); // 100ms (10 kali per detik) cukup untuk sinkronisasi subtitle

                // Dengarkan event seeking/seeked pada video untuk segera menyinkronkan waktu
                videoPlayer.addEventListener('seeking', manualSeekSync, false);
                videoPlayer.addEventListener('seeked', manualSeekSync, false);


            } catch (e) {
                console.error("[Octopus Init] ERROR FATAL saat inisialisasi SubtitleOctopus:", e);
                // Pesan status diperbarui agar lebih jelas mengenai masalahnya
                showSubtitleStatus(`Gagal merender subtitle ASS/SSA. Error: ${e.message}. Periksa apakah file worker (${OCTOPUS_WORKER_PATH}) ada.`, 'error');
                canvasElement.style.display = 'none';
            }
        }

        // Handler untuk manual seek sync
        function manualSeekSync() {
            // FIX 3: Periksa apakah renderer masih ada dan memiliki worker
            if (octopusRenderer && octopusRenderer.worker) {
                octopusRenderer.setCurrentTime(videoPlayer.currentTime);
            }
        }


        function showSubtitleStatus(message, type = 'info') { // type: 'info', 'warning', 'error', 'success'
            subtitleStatusMsg.textContent = message;
            subtitleStatusMsg.classList.remove('hidden', 'text-yellow-400', 'text-red-400', 'text-green-400', 'text-blue-400'); // Tambah blue
            if (type === 'error') {
                subtitleStatusMsg.classList.add('text-red-400');
            } else if (type === 'warning') {
                subtitleStatusMsg.classList.add('text-yellow-400');
            } else if (type === 'success') {
                subtitleStatusMsg.classList.add('text-green-400');
            } else {
                subtitleStatusMsg.classList.add('text-blue-400'); // Default info
            }

            subtitleStatusMsg.classList.remove('hidden');

            // Hapus pesan setelah beberapa detik
            const currentTimeout = subtitleStatusMsg.dataset.timeoutId;
            if (currentTimeout) clearTimeout(parseInt(currentTimeout));
            const timeoutId = setTimeout(() => {
                subtitleStatusMsg.classList.add('hidden');
                delete subtitleStatusMsg.dataset.timeoutId;
            }, 5000);
            subtitleStatusMsg.dataset.timeoutId = timeoutId.toString();
        }

        /**
         * Hapus track <track> native dan renderer Octopus.
         */
        function removeExistingSubtitleTracks() {
            // Hapus semua elemen <track> native
            const existingTrackElements = videoPlayer.querySelectorAll('track');
            existingTrackElements.forEach(trackEl => {
                if (trackEl.src && trackEl.src.startsWith('blob:')) {
                    URL.revokeObjectURL(trackEl.src);
                }
                trackEl.remove();
            });
            currentSubtitleTrackElement = null;
            if (currentTrackURL) {
                URL.revokeObjectURL(currentTrackURL); // Pastikan URL lama dicabut
                currentTrackURL = null;
            }

            // Nonaktifkan semua track teks yang mungkin tersisa
            if (videoPlayer.textTracks) {
                for (let i = 0; i < videoPlayer.textTracks.length; i++) {
                    videoPlayer.textTracks[i].mode = 'disabled';
                }
            }
            
            // Hapus listener manual sync
            videoPlayer.removeEventListener('seeking', manualSeekSync, false);
            videoPlayer.removeEventListener('seeked', manualSeekSync, false);


            // Hapus renderer Octopus
            initializeOctopus(null);
            console.log("[Subtitle] Semua track native dan Octopus renderer dihapus.");
        }

        /**
         * Menambahkan track VTT ke video (untuk SRT/MOV_TEXT).
         */
        function addVTTTrackToVideo(vttContent, trackMetadata) {
            // removeExistingSubtitleTracks(); // TIDAK di sini, tapi di selectSubtitleTrack

            if (!vttContent || vttContent.trim() === '') {
                showSubtitleStatus(`Track "${trackMetadata.label}" kosong.`, 'warning');
                return; // Jangan tambahkan track kosong
            }
            console.log(`[Subtitle] Adding VTT track: ${trackMetadata.label}`);

            const vttBlob = new Blob([vttContent], { type: 'text/vtt;charset=utf-8' });
            const trackURL = URL.createObjectURL(vttBlob);

            const trackElement = document.createElement('track');
            trackElement.kind = 'subtitles';
            trackElement.label = trackMetadata.label;
            trackElement.srclang = trackMetadata.language || 'und';
            trackElement.src = trackURL;
            trackElement.default = true; // Set as default to force showing

            currentTrackURL = trackURL; // Simpan URL baru
            currentSubtitleTrackElement = trackElement; // Simpan elemen

            trackElement.addEventListener('load', function () {
                if (this.track) {
                    this.track.mode = 'showing';
                    console.log(`[Subtitle] Track VTT "${trackMetadata.label}" loaded and set to showing.`);
                    showSubtitleStatus(`Subtitle track VTT loaded: ${trackMetadata.label}`, 'success');
                    subtitleBtn.classList.add('text-[color:var(--control-highlight)]');
                    renderSubtitleMenu(subtitleTracks);
                }
            });

            trackElement.addEventListener('error', function (e) {
                console.error(`[Subtitle] Error loading track VTT "${trackMetadata.label}":`, e);
                showSubtitleStatus(`Gagal memuat track VTT untuk "${trackMetadata.label}".`, 'error');
                removeExistingSubtitleTracks(); // Clean up on error
                subtitleBtn.classList.remove('text-[color:var(--control-highlight)]');
                renderSubtitleMenu(subtitleTracks);
            });

            // Tambahkan elemen track ke video
            videoPlayer.appendChild(trackElement);
        }

        /** Mengubah ukuran canvas subtitle agar sesuai dengan video */
        function resizeSubtitleCanvas() {
            // === FIX UTAMA: Pemeriksaan ketat sebelum mengakses dimensi video/canvas ===
            // Pastikan elemen DOM ada
            if (!videoPlayer || !subtitleCanvas) {
                return;
            }

            // Dapatkan bounding box video display area (container video dan canvas)
            const containerRect = videoDisplayArea.getBoundingClientRect();
            const containerWidth = containerRect.width;
            const containerHeight = containerRect.height;

            // Pastikan video telah memuat metadata dan memiliki dimensi yang valid
            if (!videoPlayer.videoWidth || !videoPlayer.videoHeight || videoPlayer.videoWidth === 0 || videoPlayer.videoHeight === 0) {
                console.warn("[Resize] Video metadata belum tersedia. Menggunakan dimensi kontainer penuh.");
                // Jika video belum dimuat atau dimensinya 0, pastikan canvas menutupi kontainer penuh
                subtitleCanvas.style.width = '100%';
                subtitleCanvas.style.height = '100%';
                subtitleCanvas.style.left = '0px';
                subtitleCanvas.style.top = '0px';
                
                // Set resolusi internal canvas ke dimensi container
                subtitleCanvas.width = containerWidth;
                subtitleCanvas.height = containerHeight;

                if (octopusRenderer) {
                    // Coba panggil resize Octopus dengan dimensi kontainer (fallback)
                    octopusRenderer.resize(containerWidth, containerHeight);
                }
                return;
            }
            
            // --- Logika Penyesuaian Aspek Rasio (object-fit: contain) ---
            const aspectRatio = videoPlayer.videoWidth / videoPlayer.videoHeight;
            let newWidth, newHeight;
            let videoLeft, videoTop;

            // Hitung ukuran baru berdasarkan `object-fit: contain`
            if (containerWidth / containerHeight > aspectRatio) {
                newHeight = containerHeight;
                newWidth = containerHeight * aspectRatio;
            } else {
                newWidth = containerWidth;
                newHeight = containerWidth / aspectRatio;
            }
            
            // Hitung posisi tengah
            videoLeft = (containerWidth - newWidth) / 2;
            videoTop = (containerHeight - newHeight) / 2;


            // Set ukuran dan posisi elemen canvas di DOM (UKURAN TAMPILAN)
            // Ini akan memastikan canvas persis menutupi area pemutaran video (object-fit: contain)
            subtitleCanvas.style.width = `${newWidth}px`;
            subtitleCanvas.style.height = `${newHeight}px`;
            subtitleCanvas.style.left = `${videoLeft}px`;
            subtitleCanvas.style.top = `${videoTop}px`;
            
            // Set resolusi internal canvas (UKURAN RESOLUSI RENDER)
            // Resolusi internal harus diatur ke resolusi video asli untuk rendering yang optimal
            subtitleCanvas.width = videoPlayer.videoWidth;
            subtitleCanvas.height = videoPlayer.videoHeight;
            
            // Informasikan SubtitlesOctopus tentang ukuran barunya (ukuran DOM, bukan resolusi internal)
            if (octopusRenderer) {
                // Octopus membutuhkan ukuran DOM (piksel yang terlihat) untuk rendering yang benar
                // Kita mengirim ukuran tampilan (newWidth, newHeight)
                octopusRenderer.resize(newWidth, newHeight);
            }
            console.log(`[Resize] Canvas DOM set to: ${newWidth}x${newHeight}, Internal: ${subtitleCanvas.width}x${subtitleCanvas.height}`);
        }


        // --- UPDATED: renderSubtitleMenu (Highlight logic) ---
        function renderSubtitleMenu(tracks) {
            subtitleTrackList.innerHTML = ''; // Clear list

            // Tombol 'Off'
            const offBtn = document.createElement('button');
            offBtn.dataset.trackIndex = '-1';
            offBtn.className = "w-full text-left px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700";
            offBtn.textContent = 'Off';

            // Cek apakah ada track yang sedang aktif
            let activeTrackLabel = null;
            const activeOctopusTrack = subtitleTracks.find(t => t.isOctopusActive);

            if (activeOctopusTrack) {
                activeTrackLabel = activeOctopusTrack.label;
            } else if (currentSubtitleTrackElement && currentSubtitleTrackElement.track && currentSubtitleTrackElement.track.mode === 'showing') {
                activeTrackLabel = currentSubtitleTrackElement.label; // Jika VTT native aktif
            }

            // Highlight 'Off' jika tidak ada track yang aktif
            if (!activeTrackLabel) {
                offBtn.classList.add('selected-track');
                subtitleBtn.classList.remove('text-[color:var(--control-highlight)]');
            }

            offBtn.addEventListener('click', () => {
                removeExistingSubtitleTracks();
                subtitleTracks.forEach(t => t.isOctopusActive = false); // Reset Octopus active state
                subtitleMenu.classList.add('hidden');
                renderSubtitleMenu(subtitleTracks); // Re-render to update selection state
            });
            subtitleTrackList.appendChild(offBtn);


            if (!tracks || tracks.length === 0) {
                subtitleBtn.disabled = true;
                subtitleBtn.classList.remove('text-[color:var(--control-highlight)]');
                const noTrackDiv = document.createElement('div');
                noTrackDiv.className = "px-4 py-2 text-sm text-gray-500 dark:text-gray-400";
                noTrackDiv.textContent = "No embedded tracks.";
                subtitleTrackList.appendChild(noTrackDiv);
                return;
            }

            subtitleBtn.disabled = false; // Enable if tracks exist

            tracks.forEach((track, index) => {
                const btn = document.createElement('button');
                btn.dataset.trackIndex = index;
                btn.className = "w-full text-left px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700";
                btn.textContent = track.label;

                // Highlight jika track ini sedang aktif
                if (activeTrackLabel === track.label) {
                    btn.classList.add('selected-track');
                    subtitleBtn.classList.add('text-[color:var(--control-highlight)]');
                }

                btn.addEventListener('click', () => {
                    selectSubtitleTrack(track);
                    subtitleMenu.classList.add('hidden');
                });
                subtitleTrackList.appendChild(btn);
            });
        }

        // --- UPDATED: selectSubtitleTrack (Menggunakan Octopus atau Native) ---
        async function selectSubtitleTrack(trackMetadata) {
            if (!trackMetadata.content || trackMetadata.content.trim().length <= 10) {
                console.warn(`[Subtitle] Track "${trackMetadata.label}" has no valid content. Turning subtitles off.`);
                showSubtitleStatus(`Track "${trackMetadata.label}" tidak memiliki konten subtitle yang valid.`, 'warning');
                removeExistingSubtitleTracks();
                subtitleTracks.forEach(t => t.isOctopusActive = false); // Reset Octopus active state
                renderSubtitleMenu(subtitleTracks);
                return;
            }

            const isAssSsa = trackMetadata.codec_name === 'ass' || trackMetadata.codec_name === 'ssa';

            // Reset status active Octopus pada semua track
            subtitleTracks.forEach(t => t.isOctopusActive = false);
            
            // Hapus dulu track dan renderer yang ada SEBELUM memilih yang baru
            removeExistingSubtitleTracks();

            if (isAssSsa) {
                // Gunakan Octopus untuk ASS/SSA
                try {
                    // Panggil inisialisasi Octopus
                    initializeOctopus(trackMetadata.content);
                    
                    // Jika berhasil, tandai sebagai aktif
                    if (octopusRenderer) {
                        trackMetadata.isOctopusActive = true;
                        showSubtitleStatus(`Subtitle ASS/SSA dimuat dengan Octopus.`, 'success');
                    }
                    

                } catch (e) {
                    // Jika initializeOctopus gagal (karena SubtitleOctopus belum terdefinisi)
                    console.error("[Octopus Error] Gagal menginisialisasi Octopus. Pustaka mungkin tidak termuat.", e);
                    // FIX: Perbarui pesan error untuk memperjelas masalah worker
                    showSubtitleStatus(`Gagal memuat pustaka Subtitle Octopus. Cek file subtitles-octopus.js atau pastikan file worker (${OCTOPUS_WORKER_PATH}) ada.`, 'error');
                    removeExistingSubtitleTracks();
                }

            } else {
                // Gunakan native <track> untuk VTT/SRT
                addVTTTrackToVideo(trackMetadata.content, trackMetadata);
                // addVTTTrackToVideo akan memicu renderSubtitleMenu setelah dimuat
            }

            // Jika menggunakan Octopus, update menu sekarang
            if (isAssSsa) {
                renderSubtitleMenu(subtitleTracks);
            }
        }


        // --- Logika Pemutar Video (loadVideo updated) ---
        async function loadVideo(file) {
            videoFileReference = file;

            if (currentFileURL) {
                URL.revokeObjectURL(currentFileURL);
                currentFileURL = null;
            }

            // Reset before loading new video
            removeExistingSubtitleTracks(); // Hapus track native dan Octopus
            subtitleTracks = [];
            renderSubtitleMenu([]);
            subtitleBtn.classList.remove('text-[color:var(--control-highlight)]');
            subtitleBtn.disabled = true; // Disable until tracks are checked
            subtitleStatusMsg.classList.add('hidden');
            videoTitleDisplay.textContent = "Loading..."; // Show loading state
            videoInfoDisplay.classList.remove('hidden'); // Show info area


            currentFileURL = URL.createObjectURL(file);
            videoPlayer.src = currentFileURL;
            console.log(`[Video Player] Loading video source: ${file.name}`);

            const fileName = file.name;
            videoTitleDisplay.textContent = fileName;

            // Enable basic controls immediately, subtitle button later
            toggleControlsActive(true);


            // Coba memuat subtitle yang tersemat jika file adalah MKV
            if (file.name.toLowerCase().endsWith('.mkv')) {
                try {
                    // Gunakan FFmpeg/FFprobe untuk ekstaksi
                    const loadedTracks = await extractAndProcessMkvSubtitles(file);
                    subtitleTracks = loadedTracks; // Simpan hasil
                    renderSubtitleMenu(subtitleTracks); // Perbarui UI

                    // Pilih track pertama secara default jika tersedia
                    if (subtitleTracks.length > 0) {
                        subtitleBtn.disabled = false; // Aktifkan tombol
                        // Pilih track pertama (index 0)
                        selectSubtitleTrack(subtitleTracks[0]);
                    } else {
                        subtitleBtn.disabled = true; // Tetap nonaktif jika tidak ada track
                    }
                } catch (error) {
                    showSubtitleStatus(`Gagal memproses subtitle MKV (FFmpeg worker error).`, 'error');
                    subtitleTracks = [];
                    renderSubtitleMenu([]);
                    subtitleBtn.disabled = true;
                }
            } else {
                showSubtitleStatus("File non-MKV dimuat. Tidak mencari subtitle tersemat.", 'info');
            }


            // Attempt to play
            try {
                await videoPlayer.play();
            } catch (e) {
                console.warn("[Video Player] Autoplay was prevented:", e);
                updatePlayPauseIcon();
                toggleControlsActive(true); // Ensure paused overlay shows if autoplay fails
            }
        }


        // --- Event Listeners and Initialization ---

        function updatePlayPauseIcon() {
            if (!videoPlayer || videoPlayer.paused) { // Check if videoPlayer exists
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            } else {
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            }
        }

        function setupPlayerEvents() {
            // Event Play/Pause
            playPauseBtn.addEventListener("click", () => {
                if (!videoPlayer.src || playPauseBtn.disabled) return;
                if (videoPlayer.paused) {
                    videoPlayer.play();
                } else {
                    videoPlayer.pause();
                }
            });

            // Event Previous (Skip Back 10s)
            prevBtn.addEventListener("click", () => {
                if (!videoPlayer.src || prevBtn.disabled) return;
                videoPlayer.currentTime = Math.max(0, videoPlayer.currentTime - 10);
            });

            // Event Next (Skip Forward 10s)
            nextBtn.addEventListener("click", () => {
                if (!videoPlayer.src || nextBtn.disabled) return;
                // Cek jika durasi valid sebelum menambah waktu
                if (!isNaN(videoPlayer.duration)) {
                    videoPlayer.currentTime = Math.min(videoPlayer.duration, videoPlayer.currentTime + 10);
                } else {
                    // Jika durasi tidak valid (misalnya stream), hanya maju 10 detik
                    videoPlayer.currentTime += 10;
                }
            });

            // Event Video State
            videoPlayer.addEventListener('play', () => {
                updatePlayPauseIcon();
                toggleControlsActive(true); // Sembunyikan overlay
                parent.postMessage({
                    action: "show-media-notification",
                    title: videoTitleDisplay.textContent || "Video Player",
                    artist: "Now Playing",
                    albumArt: "img/films-and-tv_171100.png",
                }, "*");
            });
            videoPlayer.addEventListener('pause', () => {
                updatePlayPauseIcon();
                if (!videoPlayer.seeking && !videoPlayer.ended) { // Jangan tampilkan overlay saat seeking atau ended
                    toggleControlsActive(true); // Tampilkan overlay "Paused"
                } else if (videoPlayer.ended) {
                    // Handle ended state specifically if needed, maybe reset overlay differently
                    toggleControlsActive(true); // Keep controls active
                    videoOverlay.style.opacity = '0'; // Ensure overlay is hidden on end
                    videoOverlay.classList.add('hidden-overlay');
                }
            });
            videoPlayer.addEventListener('ended', () => {
                updatePlayPauseIcon();
                // Optional: Reset timeline to 0
                updateTimeline(0);
                timeDisplayCurrent.textContent = formatTime(0);
                // Keep controls active but show video start state? Or reset overlay?
                toggleControlsActive(true); // Keep controls enabled
                // Show the initial overlay again
                videoOverlay.style.opacity = '1';
                videoOverlay.classList.remove('hidden-overlay');
                videoOverlay.querySelector('p').textContent = 'Video ended. Drop another file.';
                videoOverlay.querySelector('.text-xl').textContent = videoTitleDisplay.textContent || 'Video Player';
                videoOverlay.querySelector('svg').classList.add('hidden'); // Hide icon on end


            });

            videoPlayer.addEventListener('timeupdate', () => {
                if (!isTimelineDragging && !isNaN(videoPlayer.currentTime) && !isNaN(videoPlayer.duration)) {
                    const percent = (videoPlayer.duration > 0) ? (videoPlayer.currentTime / videoPlayer.duration) * 100 : 0;
                    updateTimeline(percent);
                    timeDisplayCurrent.textContent = formatTime(videoPlayer.currentTime);
                } else if (!isNaN(videoPlayer.currentTime)) {
                    timeDisplayCurrent.textContent = formatTime(videoPlayer.currentTime);
                }
            });

            videoPlayer.addEventListener('loadedmetadata', () => {
                if (!isNaN(videoPlayer.duration) && videoPlayer.duration > 0) {
                    timeDisplayDuration.textContent = formatTime(videoPlayer.duration);
                    // Enable seeking controls only if duration is valid
                    timelineContainer.style.cursor = 'pointer';
                    timelineThumb.style.cursor = 'grab';
                } else {
                    timeDisplayDuration.textContent = '--:--';
                    // Disable seeking if duration is unknown (like live stream)
                    timelineContainer.style.cursor = 'default';
                    timelineThumb.style.cursor = 'default';
                    // Consider disabling timeline interaction completely here if needed
                }
                timeDisplayCurrent.textContent = '00:00';

                // FIX 4: Panggil resizeCanvas untuk subtitle setelah metadata dimuat
                resizeSubtitleCanvas();
                
                parent.postMessage({ action: 'request-volume' }, '*');
                toggleControlsActive(true); // Ensure controls are active
                updatePlayPauseIcon();
            });

            videoPlayer.addEventListener('error', (e) => {
                console.error("[Video Player] Error:", videoPlayer.error);
                let errorMsg = 'Gagal memutar video.';
                if (videoPlayer.error) {
                    switch (videoPlayer.error.code) {
                        case MediaError.MEDIA_ERR_ABORTED: errorMsg = 'Pemutaran dibatalkan.'; break;
                        case MediaError.MEDIA_ERR_NETWORK: errorMsg = 'Kesalahan jaringan.'; break;
                        case MediaError.MEDIA_ERR_DECODE: errorMsg = 'Kesalahan decode (format?).'; break;
                        case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: errorMsg = 'Format video tidak didukung.'; break;
                        default: errorMsg = `Kesalahan tidak diketahui (Kode: ${videoPlayer.error.code}).`;
                    }
                }
                showSubtitleStatus(errorMsg, 'error');
                toggleControlsActive(false); // Disable controls on error
            });


            fullscreenBtn.addEventListener('click', () => {
                if (fullscreenBtn.disabled) return;
                try {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else if (appWindow.requestFullscreen) {
                        appWindow.requestFullscreen();
                    } else if (appWindow.webkitRequestFullscreen) {
                        appWindow.webkitRequestFullscreen();
                    } else if (appWindow.msRequestFullscreen) {
                        appWindow.msRequestFullscreen();
                    }
                } catch (err) {
                    console.error("Fullscreen request failed:", err);
                    showSubtitleStatus("Gagal masuk mode fullscreen.", 'error');
                }
            });

            volumeBtn.addEventListener('click', () => {
                if (volumeBtn.disabled) return;
                parent.postMessage({ action: 'toggle-volume-flyout' }, '*');
            });

            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && videoPlayer.src && !playPauseBtn.disabled) {
                    e.preventDefault();
                    if (videoPlayer.paused) {
                        videoPlayer.play().catch(err => console.error("Play error:", err));
                    } else {
                        videoPlayer.pause();
                    }
                }
                else if (e.code === 'ArrowLeft' && videoPlayer.src && !prevBtn.disabled && !isNaN(videoPlayer.duration) && videoPlayer.duration > 0) {
                    e.preventDefault();
                    prevBtn.click();
                } else if (e.code === 'ArrowRight' && videoPlayer.src && !nextBtn.disabled && !isNaN(videoPlayer.duration) && videoPlayer.duration > 0) {
                    e.preventDefault();
                    nextBtn.click();
                }
            });
        }

        function updateTimeline(percent) {
            percent = Math.max(0, Math.min(100, percent));
            const containerWidth = timelineContainer.offsetWidth;
            timelineFill.style.width = `${percent}%`;
            const thumbPx = (percent / 100) * containerWidth;
            // Ensure thumb stays within bounds
            const thumbHalfWidth = timelineThumb.offsetWidth / 2;
            timelineThumb.style.left = `${Math.max(thumbHalfWidth, Math.min(thumbPx, containerWidth - thumbHalfWidth))}px`;
        }


        function getPercentFromClientX(container, clientX) {
            const sliderRect = container.getBoundingClientRect();
            const offsetX = clientX - sliderRect.left;
            const containerWidth = container.offsetWidth;
            return Math.max(0, Math.min(100, (offsetX / containerWidth) * 100));
        }

        function seekVideo(clientX) {
            if (!videoPlayer.src || isNaN(videoPlayer.duration) || videoPlayer.duration <= 0) return;
            const percent = getPercentFromClientX(timelineContainer, clientX);
            updateTimeline(percent);
            videoPlayer.currentTime = (percent / 100) * videoPlayer.duration;
            timeDisplayCurrent.textContent = formatTime(videoPlayer.currentTime);
            
            // Manual sync untuk Octopus saat seek
            if (octopusRenderer && octopusRenderer.worker) {
                octopusRenderer.setCurrentTime(videoPlayer.currentTime);
            }
        }


        function setupTimelineEvents() {
            timelineThumb.addEventListener('mousedown', (e) => {
                // Allow dragging only if duration is valid
                if (!videoPlayer.src || isNaN(videoPlayer.duration) || videoPlayer.duration <= 0) return;
                isTimelineDragging = true;
                timelineThumb.style.transform = 'translate(-50%, -50%) scale(1.1)';
                document.body.style.cursor = 'grabbing';
                videoPlayer.pause(); // Pause while scrubbing
                
                // Pause Octopus rendering
                if (octopusRenderer && octopusRenderer.worker) {
                    octopusRenderer.setIsPaused(true, videoPlayer.currentTime);
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isTimelineDragging && !isNaN(videoPlayer.duration) && videoPlayer.duration > 0) {
                    const percent = getPercentFromClientX(timelineContainer, e.clientX);
                    updateTimeline(percent);
                    const newTime = (percent / 100) * videoPlayer.duration;
                    timeDisplayCurrent.textContent = formatTime(newTime);
                    // Optionally update video currentTime live while dragging (can be laggy)
                    // videoPlayer.currentTime = newTime;
                    
                    // Update Octopus time live while dragging (Opsional, dapat menyebabkan lag)
                    if (octopusRenderer && octopusRenderer.worker) {
                        octopusRenderer.setCurrentTime(newTime);
                    }
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (isTimelineDragging) {
                    isTimelineDragging = false;
                    timelineThumb.style.transform = 'translate(-50%, -50%)';
                    document.body.style.cursor = 'default';
                    // Final seek on mouseup
                    seekVideo(e.clientX);
                    videoPlayer.play().catch(err => console.warn("Could not resume playing after scrub:", err)); // Try to resume playing
                    
                    // Resume Octopus rendering
                    if (octopusRenderer && octopusRenderer.worker) {
                        octopusRenderer.setIsPaused(false, videoPlayer.currentTime);
                    }
                }
            });

            timelineContainer.addEventListener('click', (e) => {
                if (e.target !== timelineThumb && !isNaN(videoPlayer.duration) && videoPlayer.duration > 0) {
                    seekVideo(e.clientX);
                }
            });
        }

        function setupSubtitleEvents() {
            subtitleBtn.addEventListener('click', (e) => {
                if (subtitleBtn.disabled) return;
                e.stopPropagation();
                subtitleMenu.classList.toggle('hidden');
            });

            document.addEventListener('click', (e) => {
                // Close menu if clicked outside, unless clicking the button itself
                if (!subtitleMenu.classList.contains('hidden') && !subtitleMenu.contains(e.target) && e.target !== subtitleBtn && !subtitleBtn.contains(e.target)) {
                    subtitleMenu.classList.add('hidden');
                }
            });

            renderSubtitleMenu([]);

            // NEW: Tambahkan event listener untuk resize agar canvas Octopus menyesuaikan
            window.addEventListener('resize', () => {
                // Ini akan dipanggil saat jendela browser diubah ukurannya
                // Panggil resizeSubtitleCanvas untuk menghitung ulang posisi dan ukuran
                resizeSubtitleCanvas();
            });
            
            // Perlu dipanggil segera setelah window load untuk memastikan ukuran canvas sudah benar,
            // terutama jika video di load via autoplay atau secara cepat.
            resizeSubtitleCanvas(); 
        }

        function setupDragAndDrop() {
            const dropZone = videoDisplayArea;

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                let hasVideo = false;
                // Use try-catch for items access as it can throw errors in some scenarios
                try {
                    if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
                        for (let i = 0; i < e.dataTransfer.items.length; i++) {
                            if (e.dataTransfer.items[i].kind === 'file' && (e.dataTransfer.items[i].type.startsWith('video/') || e.dataTransfer.items[i].type === 'video/x-matroska')) {
                                hasVideo = true;
                                break;
                            }
                        }
                    } else if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                        for (let i = 0; i < e.dataTransfer.files.length; i++) {
                            const file = e.dataTransfer.files[i];
                            if (file.type.startsWith('video/') || file.name.toLowerCase().endsWith('.mkv') || file.type === 'video/x-matroska') {
                                hasVideo = true;
                                break;
                            }
                        }
                    }
                } catch (err) {
                    console.warn("Error accessing dataTransfer items:", err);
                    // Fallback check based on files if items access failed
                    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                        for (let i = 0; i < e.dataTransfer.files.length; i++) {
                            const file = e.dataTransfer.files[i];
                            if (file.type.startsWith('video/') || file.name.toLowerCase().endsWith('.mkv') || file.type === 'video/x-matroska') {
                                hasVideo = true;
                                break;
                            }
                        }
                    }
                }


                if (hasVideo) {
                    dropZone.classList.add('drag-over');
                    e.dataTransfer.dropEffect = 'copy';
                } else {
                    dropZone.classList.remove('drag-over'); // Remove highlight if no valid file
                    e.dataTransfer.dropEffect = 'none';
                }
            });

            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                // Add a small delay or check relatedTarget to prevent flickering when moving over child elements
                if (!dropZone.contains(e.relatedTarget)) {
                    dropZone.classList.remove('drag-over');
                }
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('drag-over');

                let videoFile = null;
                try {
                    if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
                        for (let i = 0; i < e.dataTransfer.items.length; i++) {
                            if (e.dataTransfer.items[i].kind === 'file') {
                                const file = e.dataTransfer.items[i].getAsFile();
                                if (file && (file.type.startsWith('video/') || file.name.toLowerCase().endsWith('.mkv') || file.type === 'video/x-matroska')) {
                                    videoFile = file;
                                    break;
                                }
                            }
                        }
                    } else if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                        for (let i = 0; i < e.dataTransfer.files.length; i++) {
                            const file = e.dataTransfer.files[i];
                            if (file.type.startsWith('video/') || file.name.toLowerCase().endsWith('.mkv') || file.type === 'video/x-matroska') {
                                videoFile = file;
                                break;
                            }
                            // NEW: Cek jika file drop adalah file ASS/SRT eksternal
                            if (file.name.toLowerCase().endsWith('.ass') || file.name.toLowerCase().endsWith('.srt')) {
                                // Jika file subtitle eksternal di-drop, kita bisa menambahkannya sebagai track eksternal
                                // NAMUN, karena kita fokus pada ekstrak MKV, kita biarkan hanya video yang diproses loadVideo
                                // Untuk menyederhanakan, kita hanya proses file video yang di-drop.
                            }
                        }
                    }
                } catch (err) {
                    console.error("Error processing dropped files:", err);
                    showSubtitleStatus("Gagal memproses file yang di-drop.", 'error');
                    return; // Exit if error processing files
                }


                if (videoFile) {
                    loadVideo(videoFile);
                } else {
                    videoOverlay.style.opacity = '1';
                    videoOverlay.classList.remove('hidden-overlay');
                    videoOverlay.querySelector('.text-xl').textContent = 'File Not Supported';
                    videoOverlay.querySelector('p').textContent = 'Please drop a video file (.mp4, .webm, .mkv)';
                    videoOverlay.querySelector('svg').classList.remove('hidden');
                    showSubtitleStatus("Hanya file video (.mp4, .webm, .mkv) yang didukung.", 'warning');
                }
            });
        }

        header.addEventListener("mousedown", (e) => {
            if (isMaximized || e.target.closest('button')) return;
            isDragging = true;
            parent.postMessage({ action: "bring-vp-to-front" }, "*");
            e.preventDefault();
        });

        window.addEventListener("mousemove", (e) => {
            if (isDragging) {
                parent.postMessage({ action: "drag-vp-frame", dx: e.movementX, dy: e.movementY }, "*");
            }
        });

        window.addEventListener("mouseup", () => {
            if (isDragging) isDragging = false;
        });
        window.addEventListener("mouseleave", () => {
            if (isDragging) isDragging = false;
        });

        closeBtn.addEventListener("click", () => parent.postMessage({ action: "close-vp-frame" }, "*"));
        minimizeBtn.addEventListener("click", () => parent.postMessage({ action: "minimize-vp-frame" }, "*"));
        maximizeBtn.addEventListener("click", () => parent.postMessage({ action: "maximize-vp-frame" }, "*"));

        window.addEventListener("message", (event) => {
            const { action, isDark, value, volume, isMaximized: newMaximizedState, borderRadius } = event.data;

            if (action === "theme-change") {
                document.body.classList.toggle("dark", isDark);
            }
            if (action === "toggle-fancy-mode") {
                document.body.classList.toggle("fancy-mode", value);
            }
            if (action === "set-volume" && videoPlayer) {
                if (typeof volume === 'number' && volume >= 0 && volume <= 100) {
                    videoPlayer.volume = volume / 100;
                }
            }
            if (action === "set-maximized-state") {
                isMaximized = newMaximizedState;
                appWindow.classList.toggle('maximized', isMaximized);
                if (isMaximized) {
                    maximizeBtn.title = "Restore Down";
                    maximizeBtn.innerHTML = `<svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d=\"M3 1H9V7H3V1ZM2 0H10V8H2V0Z\" fill=\"currentColor\"/><path d=\"M1 3H7V9H1V3ZM0 2H8V10H0V2Z\" fill=\"currentColor\" opacity=\"0.5\"/></svg>`;
                    appWindow.style.borderRadius = borderRadius || "0";
                    header.style.padding = '3px 3px 3px 6px';
                } else {
                    maximizeBtn.title = "Maximize";
                    maximizeBtn.innerHTML = `<svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9 1V9H1V1H9ZM10 0H0V10H10V0Z" fill=\"currentColor\"/></svg>`;
                    appWindow.style.borderRadius = "8px";
                    header.style.padding = '3px 3px 3px 6px';
                }
            }
        });

        window.addEventListener('load', () => {
            // Cek inisialisasi worker
            if (typeof Worker === 'undefined') {
                showSubtitleStatus("Browser Anda tidak mendukung Web Worker, FFmpeg/FFprobe tidak dapat digunakan.", 'error');
            } else {
                console.log("Web Workers available for FFmpeg/FFprobe.");
            }

            setupPlayerEvents();
            setupTimelineEvents();
            setupDragAndDrop();
            setupSubtitleEvents();
            parent.postMessage({ action: 'request-settings' }, '*');
            toggleControlsActive(false); // Initial state is inactive
        });

    </script>
</body>

</html>